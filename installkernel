#!/bin/sh
##
## installkernel - Script for installing Linux kernel.
## $Id: installkernel,v 1.34 2006/12/18 19:36:01 mina86 Exp $
## Copyright (c) 2004-2006 by Michal Nazarewicz (mina86/AT/mina86.vom)
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##


##
## Basic initialization
##
set -e
USER="$(id -un)"
ARG0="${0##*/}"
LOWER_CHARS=abcdefghijklmnopqrstuvwxyz-
UPPER_CHARS=ABCDEFGHIJKLMNOPQRSTUVWXYZ_
trap "" USR1 USR2


##
## Some nice functions
##
toInt () {
	expr 0$(expr "X$1" : 'X[[:space:]]*\([0-9]*\)') + 0 2>/dev/null || true
}


##
## Version
##
if [ -z "$INSIDE_INSTALLKERNEL" ]; then
	echo 'installkernel  v0.14.2  (c) 2004-2006 by Micha³ Nazarewicz'
	echo '$Id: installkernel,v 1.34 2006/12/18 19:36:01 mina86 Exp $'
	echo

	# Lockfile check
	if [ -f /tmp/installkernel-lockfile ]; then
		echo "$ARG0: lockfile exists"
		PID="$(toInt "`cat /tmp/installkernel-lockfile`")"
		if [ $PID -ne 0 ] && kill -0 $PID >/dev/null 2>&1; then
			echo "$ARG0: make sure only one instance of installkernel is running"
			echo "$ARG0: or remove /tmp/installkernel-lockfile if that is the case"
			exit 4
		fi
		unset PID
		echo "$ARG0: looks like invalid termination; removing lockfile"
	fi

	# write lockfile
	printf "%d" $$ >|/tmp/installkernel-lockfile

	# ps check
	if PS="$(ps -C "$ARG0" 2>/dev/null)" && \
		[ $(printf %s "$PS" | wc -l) -gt 2 ]; then
		echo "$ARG0: seems like another instance of installkernel is running"
		printf "%s: abort with Ctrl-C or wait 5 seconds for script to continue" "$ARG0"
		I=0
		while [ $I -lt 5 ]; do
			if ! sleep 1; then
				echo
				rm -f /tmp/installkernel-lockfile
				exit 4
			else
				I=$(($I + 1))
				printf .
			fi
		done
		unset I
	fi
	unset PS
fi


##
## Help
##
usage () {
	cat<<END
usage: installkernel [<options>] [<switches>]
                     [<version> [<image> [<systemmap> [<prefix>]]]]
<options> are:
  -h --help             Displays this screen and exits
  -V --version          Displays vesion and exits

  -a --arch=<arch>      Sets the ARCH variable                        [auto]
     --bootdir=<dir>    Installs images to <dir>                      [/boot]
     --cd=<dir>         Changes directory to <dir>
     --cd               Synonym of --cd=/usr/src/linux

     --su               Tries to became root (implies --user=<current-user>)
  -u --user=<user>      Runs everything not requiring SU privilages as <user>
  -nu --no-user         Synonym of  --user=
     --nice=<nice>      Adjust priority by <nice> (but never lower)
     --nice=!<nice>     Set pririty to <nice>     (but never lower)   [10]
     --no-nice          Synonym of  --nice=0

  -L --log=<file>       Logs everything to <file> not to stdout
  -L --log              Logs to automaticly choosen file
  -nL --no-log          Cancels previous --log options

<switches> are:
     --dry-run          Only displays what would be done              [no]
     --print-commands   Prints commands (like --dry-run)              [no]
  -v --verbose          Becomes a lot more verbose                    [no]
  -vv                   Becomes even more verbose                     [no]
     --color            Uses colors                                   [auto]

     --run-hooks        Runs all hooks                                [yes]
     --run-pre-hooks    Runs all pre-* hooks                          [yes]
     --run-post-hooks   Runs all post-* hooks                         [yes]
     --run-<hook>       Runs <hook>'s scripts                         [yes]
     --run-<event>      Synonym of  --run-pre-<event> --run-post-<hook>

  -c --clean            Runs 'make clean' before compilation          [no]
  -C --config           Runs 'make (x|g|menu|)config' to configure    [no]
  -C --config=<cfg>     Specifies a type of config to run             [auto]
  -d --make-dep         Runs 'make dep'                               [auto]

  -O --overwrite        Overwrites the kernel image                   [no]

  -A --all              Synonym of all of the below

  -i --compile-image    Runs 'make bzImage' to compile image          [no]
  -I --install-image    Copies kernel to /boot and updates symlinks   [*]
     --tidy-image       Removes old images                            [no]
     --image            Synonym of the three above

  -m --compile-modules  Runs 'make modules'                           [no]
  -M --install-modules  Runs 'make modules_install'                   [no]
     --tidy-modules     Removes old modules                           [no]
     --modules          Synonym of the three above

     --compile          Synonym of  --compile-image --compile-modules
     --install          Synonym of  --install-image --install-modules
     --tidy             Synonym of  --tidy-image --tidy-modules

  -l --update-loader    Runs 'lilo' to update boot loader  entry      [*]

<version>   kernel version (default: reads from include/linux/version.h)
<image>     path to kernel image (default: arch/\$ARCH/boot/bzImage)
<systemmap> path to System.map file (default: System.map)
<prefix>    directory where to install the kernal image               [/boot]

[*] yes if only <version> <image> <systemmap> and <bootdir> where given.

See 'man 8 installkernel' for further infoormation.

END
}


##
## Printing helpers
##
error () {
	__EC="$1"
	shift
	echo "${0##*/}: $*" >&2
	INSTALLKERNEL_EXITED=$__EC
	exit $__EC
}

msg () {
	if [ -n "$USE_ANSI" ] && [ -n "$1" ]
	then printf '  \33[%sm%-7s %s\33[0m\n' "$1" "$2" "$3"
	else printf '  %-7s %s\n' "$2" "$3"
	fi
}


##
## Signals etc
##
sig_handler () {
	msg 31 SIG "Got SIG$1; terminating..."
	error 5 "Got SIG$1; terminating..."
}

for E in HUP INT QUIT ILL ABRT FPE SEGV PIPE ALRM TERM TSTP; do
	trap "sig_handler $E" $E
done

exit_function () {
	__EC=$?
	rm -f /tmp/installkernel-$$ /tmp/installkernel-lockfile
	if [ "X$LOG_AUTO" = Xstarted ]; then
		date +'---- END ---- installkernel log file --- %y/%m/%d %H:%M:%S ---'
	fi
	if [ $__EC -ne 0 ] && [ "X$INSTALLKERNEL_EXITED" != "X$__EC" ]; then
		msg 31 ERR "Comand's exit code: $__EC"
		error $__EC "Comand's exit code: $__EC"
	fi
	return 0
}

trap exit_function 0


##
## Prints header
##
if [ -z "$COLUMNS" ]; then
	COLS=`toInt "$(stty -a | sed -ne 's/^.*columns[[:space:]][[:space:]]*\([0-9][0-9]*\).*$/\1/p')"`
	if [ $COLS -gt 30 ]; then
		export COLUMNS=$COLS
	fi
fi

header () {
	__TITLE="$*"
	if [ -n "$USE_ANSI" ]
	then printf "\33[32m=== \33[1m%s\33[0;32m " "$__TITLE"
	else printf "=== %s " "$__TITLE"
	fi

	__LOOP=$(( ${COLUMNS-80} - ${#__TITLE} - 29))
	__STR=
	while [ $__LOOP -gt 0 ]; do
		__STR="$__STR="
		__LOOP=$(( $__LOOP - 1 ))
	done

	date +"$__STR [%y/%m/%d %H:%M:%S] ==="
	if [ -n "$USE_ANSI" ]; then printf '\33[0m'; fi
	return 0
}


##
## Runs command
##
run () {
	__AS=
	__SILENT=
	__DUMMY=
	__FORCE=
	__INPUT=/dev/stdin
	__OUTPUT=/dev/stdout

	# Arguments
	while expr "X$1" : X- >/dev/null 2>&1; do
		__ARG="${1#-}"; shift;
		while [ -n "$__ARG" ]; do
			case "$__ARG" in
				(u*) __AS="$RUNAS"; ;;
				(s*) __SILENT=yes ; ;;
				(f*) __FORCE=yes  ; ;;
				(d*) __DUMMY=yes  ; ;;
				(i*) __INPUT="$1" ; shift; ;;
				(o*) __OUTPUT="$1"; shift; ;;
			esac
			__ARG="${__ARG#?}"
		done
	done

	# Dry run
	if [ -n "$DRY_RUN$PRINT_COMMANDS" ] && [ -z "$__SILENT" ]; then
		if [ $__AS ]; then __MSG="[as $__AS] "; else __MSG=""; fi
		__END=""
		if [ "$__INPUT"  != /dev/stdin  ]; then __END="<$__INPUT "; fi
		if [ "$__OUTPUT" != /dev/stdout ]; then __END="$__END>$__OUTPUT"; fi
		msg '36' RUN "$__MSG`printf "'%s' " "$@"`$__END"
	fi

	# Don't run really
	if [ -n "$DRY_RUN" ] && [ -z "$__FORCE" ]; then return 0; fi
	if [ -n "$__DUMMY" ]; then return 0; fi

	# cd cannot be run throught su or nice
	if [ "X$1" = Xcd ]; then
		"$@"
		return $?
	fi

	# Run not as
	if [ -z "$__AS" ] || [ "X$__AS" = "X$USER" ]; then
		"$@" <"$__INPUT" >"$__OUTPUT"
		return $?
	fi

	# Run as
	__ARGS=
	while [ $# -ne 0 ]; do
		__ARGS="$__ARGS '`echo "$1" | sed -e "s/'/'\\\\''/"`'"
		shift
	done

	su "$__AS" -c "$__ARGS" <"$__INPUT" >"$__OUTPUT"
	return $?
}


##
## Runs /etc/installekrnel.d/$1/* scripts
##
run_scripts () {
	__DIR=$1; shift
	if eval [ -z \"\$RUN_`echo $__DIR | tr $LOWER_CHARS $UPPER_CHARS`\" ]
	then return 0; fi

	for __SCRIPT in /etc/installkernel.d/global/* /etc/installkernel.d/$__DIR/*; do
		if [ -x "$__SCRIPT" ]; then
			run "$@" "$__SCRIPT" $__DIR
		fi
	done
}


##
## Prints header, run_scripts and run
##
r () {
	if [ "X$1" = X-u ]; then __USR=-u; shift; else __USR=; fi
	if eval [ -z \"\$$1\" ]; then return 0; fi
	__NAME=`echo $1 | tr $UPPER_CHARS $LOWER_CHARS`
	header "$2"
	shift 2
	run_scripts pre-$__NAME $__USR
	run $__USR "$@"
	run_scripts post-$__NAME $__USR
}


##
## Reads kernel version number
##
update_ver () {
	if [ -n "$VER" ]; then return 0; fi
	run -ud make -f- $MAKEV installkernel-print-version '<<EOF ... EOF'
	VER=$(run -usf make -f- $MAKEV installkernel-print-version <<EOF
include Makefile
installkernel-print-version:
	@VER=\$\${KERNELVERSION:-\$\$KERNELRELEASE}; \
	echo "\$\${VER:?no version information found}"
EOF
);
	msg '37;1' VER "$VER"
}


##
## Set hooks
##
set_run_hooks () {
	for EVENT in CLEAN CONFIG MAKE_DEP UPDATE_LOADER \
		COMPILE_IMAGE INSTALL_IMAGE TIDY_IMAGE \
		COMPILE_MODULES INSTALL_MODULES TIDY_MODULES; do
		if [ -n "$2" ]
		then eval export RUN_$2$EVENT=$1
		else eval export RUN_PRE_$EVENT=$1 RUN_POST_$EVENT=$1
		fi
	done
	if [ -n "$2" ]
	then eval export RUN_${2%_}=$1
	else eval export RUN_PRE=$1 RUN_POST=$1
	fi
}


if [ -z "$INSIDE_INSTALLKERNEL" ]; then
	##
	## Init default options
	##
	if [ -z "$INSTALL_PATH" ]; then export INSTALL_PATH=/boot; fi

	SU=; LOG_AUTO=; LOG_FILE=; NICE=!10; __ARCH="$ARCH"
	export VER= BUILD= IMG_PATH= MAP_PATH= RUNAS= ARCH=

	export DRY_RUN= PRINT_COMMANDS= VERBOSE= REALLY_VERBOSE=
	if [ -t 1 ]; then export USE_ANSI=y; else export USE_ANSI=; fi

	export CLEAN= COMPILE_IMAGE= COMPILE_MODULES= INSTALL_IMAGE=
	export INSTALL_MODULES= UPDATE_LOADER= TIDY_IMAGE= TIDY_MODULES=
	export CONFIG= CONFIG_TYPE=auto MAKE_DEP=auto OVERWRITE_IMAGE=

	set_run_hooks y


	##
	## Parse arguments
	##
	ADD_ARGS=0
	NUMARGS=$#
	for ARG; do
		PARAM=

		## Options
		case "$ARG" in
		(--help|-h) usage; exit 0; ;;
		(--version|-V) exit 0; ;;

		(--arch=*)         ARCH="${ARG#--arch=}"; ;;
		(-a*)              ARCH="${ARG#-a}";      ;;
		(--bootdir=*)      INSTALL_PATH="${ARG#--bootdir=}"; ;;
		(--cd=*)           CD="${ARG#--cd=}"; ;;
		(--cd)             CD=/usr/src/linux; ;;

		(--config=no)      CONFIG=; ;;
		(--config=auto)    CONFIG=y; CONFIG_TYPE=auto; ;;
		(--config=*config) CONFIG=y; CONFIG_TYPE="${ARG#--config=}"; ;;
		(--config=*)       error 1 invalid config type: "${ARG#--config=}"; ;;

		(--su)          SU=y; RUNAS="$USER"; ;;
		(--user=*)      RUNAS="${ARG#--user=}"; ;;
		(-u*)           RUNAS="${ARG#-u}"; ;;
		(-nu|--no-user) RUNAS=; ;;
		(--nice=*)      NICE="${ARG#--nice=}"; ;;
		(--no-nice)     NICE=0; ;;

		(--log=*)       LOG_AUTO=;  USE_ANSI=; LOG_FILE="${ARG#--log=}"; ;;
		(-L*)           LOG_AUTO=;  USE_ANSI=; LOG_FILE="${ARG#-L}";     ;;
		(--log)         LOG_AUTO=y; USE_ANSI=; ;;
		(-L)            LOG_AUTO=y; USE_ANSI=; ;;
		(-nL|--no-log)  LOG_AUTO=;  LOG_FILE=; ;;

		(-n?)    VALUE= : PARAM="-${ARG#-n}"; ;;
		(--no-*) VALUE= ; PARAM="--${ARG#--no-}"; ;;
		(--*)    VALUE=y; PARAM="--${ARG#--}"; ;;
		(-?)     VALUE=y; PARAM="$ARG"; ;;

		(*)
			if   [ $ADD_ARGS -eq 0 ]; then VER="$ARG"
			elif [ $ADD_ARGS -eq 1 ]; then IMG_PATH="$ARG"
			elif [ $ADD_ARGS -eq 2 ]; then MAP_PATH="$ARG"
			elif [ $ADD_ARGS -eq 3 ]; then INSTALL_PATH="$ARG"
			else error 1 unknown option: "$ARG"
			fi
			ADD_ARGS=$(( $ADD_ARGS + 1 ))
		;;
		esac


		## Switches
		if [ -z "$PARAM" ]; then continue; fi
		HOOK=
		case "$PARAM" in
		(--dry-run)        DRY_RUN=$VALUE ; ;;
		(-v|--verbose)     VERBOSE=$VALUE ;
		                   if [ -n "$VALUE" ]; then PRINT_COMMANDS=y; fi; ;;
		(-vv)              REALLY_VERBOSE=$VALUE;
                   if [ -n "$VALUE" ]; then VERBOSE=y; PRINT_COMMANDS=y; fi; ;;
		(--print-commands) PRINT_COMMANDS=$VALUE; ;;
		(--color)          USE_ANSI=$VALUE; ;;

		(-c|--clean)           CLEAN=$VALUE          ; ;;
		(-C|--config)          CONFIG=$VALUE         ; ;;
		(-d|--make-dep)        MAKE_DEP=$VALUE       ; ;;

		(-O|--overwrite)       OVERWRITE_IMAGE=$VALUE; ;;

		(-i|--compile-image)   COMPILE_IMAGE=$VALUE  ; ;;
		(-I|--install-image)   INSTALL_IMAGE=$VALUE  ; ;;
		(--tidy-image)         TIDY_IMAGE=$VALUE     ; ;;
		(--image)              COMPILE_IMAGE=$VALUE  ;
                               INSTALL_IMAGE=$VALUE  ; TIDY_IMAGE=$VALUE;;

		(-m|--compile-modules) COMPILE_MODULES=$VALUE; ;;
		(-M|--install-modules) INSTALL_MODULES=$VALUE; ;;
		(-t|--tidy-modules)    TIDY_MODULES=$VALUE   ; ;;
		(--modules)            COMPILE_MODULES=$VALUE;
                               INSTALL_MODULES=$VALUE; TIDY_MODULES=$VALUE;;

		(--compile) COMPILE_IMAGE=$VALUE; COMPILE_MODULES=$VALUE; ;;
		(--install) INSTALL_IMAGE=$VALUE; INSTALL_MODULES=$VALUE; ;;
		(--tidy)    TIDY_IMAGE=$VALUE   ; TIDY_MODULES=$VALUE   ; ;;

		(-l|--lilo|--update-loader)       UPDATE_LOADER=$VALUE  ; ;;

		(-A|--all)
			COMPILE_IMAGE=$VALUE  ; COMPILE_MODULES=$VALUE
			INSTALL_IMAGE=$VALUE  ; INSTALL_MODULES=$VALUE
			TIDY_IMAGE=$VALUE     ; TIDY_MODULES=$VALUE
			UPDATE_LOADER=$VALUE
			;;

		(--run-*) HOOK="${PARAM#--run-}"; ;;

		(*) error 1 unknown option: "$ARG"; ;;
		esac


		## Hooks
		if [ -z "$HOOK" ]; then continue; fi

		if   expr "X$HOOK" : Xpre-  >/dev/null 2>&1
		then PRE='PRE_' ; HOOK="${HOOK#pre-}"
		elif expr "X$HOOK" : Xpost- >/dev/null 2>&1
		then PRE='POST_'; HOOK="${HOOK#post-}"
		else PRE=; fi

		case "$HOOK" in
		(hooks) set_run_hooks "$VALUE" "$PRE"; ;;

		(clean|config|make-dep|update-loader|compile-image|install-image|tidy-image|compile-modules|install-modules|tidy-modules)
			EVENT=`echo $HOOK | tr $LOWER_CHARS $UPPER_CHARS`
			if [ -n "$PRE" ]
			then eval RUN_$PRE$EVENT=$VALUE
			else eval RUN_PRE_$EVENT=$VALUE RUN_POST_$EVENT=$VALUE
			fi
			;;

		(pre|post)
			if [ -n "$PRE" ]; then
				error 1 event $HOOK cannot have pre-/post- prefix
			fi
			EVENT=`echo $HOOK | tr $LOWER_CHARS $UPPER_CHARS`
			eval RUN_$EVENT=$VALUE
			;;

		(*) error 1 unknown event: "$HOOK"; ;;
		esac
	done

	## 'make install' run
	if [ $NUMARGS -eq 4 ] && [ $ADD_ARGS -eq 4 ]; then
		INSTALL_IMAGE=y
		UPDATE_LOADER=y
	fi


	##
	## Print header and start logging
	##
	if [ -n "$LOG_FILE" ] || [ -n "$LOG_AUTO" ]; then
		if [ -n "$LOG_AUTO" ]; then LOG_FILE=installkernel-log; fi
		if [ -n "$LOG_AUTO" ] && [ -f "$LOG_FILE" ]; then
			I=1
			while [ -f "$LOG_FILE.$I" ]; do I=$(( $I + 1 )); done
			LOG_FILE="$LOG_FILE.$I"
		fi
		echo "${0##*/}: logging output to '$LOG_FILE'"
		exec >>"$LOG_FILE"
		exec 2>&1
		FMT='+--- START --- installkernel log file --- %y/%m/%d %H:%M:%S ---'
		if [ -n "$DRY_RUN" ]; then FMT="$FMT [dry run]"; fi
		date "$FMT"
		LOG_AUTO=started
	fi

	header Starting

	export INSIDE_INSTALLKERNEL=y
	if [ -n "$VERBOSE" ]; then V=v; VOPT=-v; fi
	if [ -n "$REALLY_VERBOSE" ]; then MAKEV='v=1'; fi
	unset KBUILD_OUTPUT


	##
	## Calculate nice
	##
	if [ X"${NICE#!}" != X"$NICE" ]; then
		NICE=$((`toInt "${NICE#!}"` - `nice`))
	else
		NICE=`toInt "$NICE"`
	fi
	if [ "$NICE" -gt 0 ]; then
		msg '37;1' NICE "$NICE"
		if [ -n "$VERBOSE" ]; then renice +$NICE -p $$
		else renice $NICE -p $$ >/dev/null 2>&1; fi
	fi
	unset NICE


	##
	## Set ARCH
	##
	if [ X"$ARCH" = X- ]; then
		ARCH="$__ARCH"
	fi
	unset __ARCH
	if [ -z "$ARCH" ]; then
		ARCH=`uname -m | sed -e 's/i.86/i386/' -e 's/sun4u/sparc64/' \
	                         -e 's/arm.*/arm/' -e 's/sa110/arm/' \
	                         -e 's/s390x/s390/' -e 's/parisc64/parisc/'`
		msg '37;1' ARCH "$ARCH"
	fi


	##
	## Change directory
	##
	if [ -n "$CD" ]; then
		run -f cd "$CD"
	fi


	##
	## Become root ?
	##
	if [ -n "$SU" ] && [ "`id -u`" -ne 0 ]; then
		msg '37;1' SU "Becoming super user"
		unset SU

		if [ -n "$DRY_RUN" ]; then
			echo Here you would be asked for root password.
		else
			case "$0" in
				(/*)  ARGS="$0"; ;;
				(*/*) ARGS="$PWD/$0"; ;;
				(*)   ARGS=$(which "$0"); ;;
			esac
			ARGS="'$(echo "$ARGS" | sed -e "s/'/'\\\\''/")'"
			while [ $# -ne 0 ]; do
				ARGS="$ARGS '$(echo "$1" | sed -e "s/'/'\\\\''/")'"
				shift
			done
			exec su -c "sh $ARGS"
			exit $?
		fi
	fi
else
	if [ -n "$VERBOSE" ]; then V=v; VOPT=-v; fi
	if [ -n "$REALLY_VERBOSE" ]; then MAKEV='v=1'; fi
fi


run_scripts pre


##
## Make dep?
##
if [ -n "$COMPILE_IMAGE" ] && [ "X$MAKE_DEP" = Xauto ]; then
	update_ver
	if expr "X$VER" : 'X2\.4\.' >/dev/null 2>&1
	then MAKE_DEP=y; else MAKE_DEP=; fi
elif [ "X$MAKE_DEP" = Xauto ]; then
	MAKE_DEP=
fi


##
## Check config type
##
if [ -n "$CONFIG" ] && [ "X$CONFIG_TYPE" = Xauto ]; then
	if [ -n "$DISPLAY" ]; then
		if   which qtconfig   >/dev/null 2>&1; then CONFIG_TYPE=xconfig
		elif which gtk-config >/dev/null 2>&1; then CONFIG_TYPE=gconfig
		fi
	fi

	if [ "X$CONFIG_TYPE" = Xauto ]; then
		CONFIG_TYPE=config
		for DIR in /usr/lib /usr/local/lib /lib; do
			for LIB in curses.a curses.so ncurses.a ncurses.so; do
				if [ -f "$DIR/lib$LIB" ] || [ -f "${DIR}64/lib$LIB" ]; then
					CONFIG_TYPE=menuconfig
					break 2
				fi
			done
		done
	fi
fi


##
## make *
##
r -u CLEAN           'Cleaning source tree'   make $MAKEV clean
r -u CONFIG          'Configuring the kernel' make $MAKEV "$CONFIG_TYPE"
r -u MAKE_DEP        'Updating dependencies'  make $MAKEV dep
r -u COMPILE_IMAGE   'Compiling bzImage'      make $MAKEV bzImage
r -u COMPILE_MODULES 'Compiling modules'      make $MAKEV modules
r    INSTALL_MODULES 'Installing modules'     make $MAKEV modules_install


##
## Removing old images
##
if [ -n "$TIDY_IMAGE" ]; then
	header Removing old image
	run_scripts pre-tidy-image

	if [ -z "$OVERWRITE_IMAGE" ]; then T='~'; else T=; fi

	for FILE in bzImage System.map config; do
		msg '37;1' READLNK "$FILE$T"
		run -d readlink "$INSTALL_PATH/$FILE$T"
		LNK=`readlink "$INSTALL_PATH/$FILE$T" || true`
		if [ -f "$INSTALL_PATH/$LNK" ]; then
			msg '37;1' RM "$LNK"
			run rm -f$V -- "$INSTALL_PATH/$LNK"
		fi
	done

	run_scripts post-tidy-image
fi


##
## Removing old modules
##
if [ -n "$TIDY_MODULES" ]; then
	header Removing old modules
	run_scripts pre-tidy-modules

	update_ver

	msg '37;1' READLNK bzImage
	run -d readlink "$INSTALL_PATH/bzImage"
	if OVER="`readlink "$INSTALL_PATH/bzImage"` 2>/dev/null"; then
		OVER=${OVER#bzImage-}
		OVER=`printf "%s" "$OVER" | sed -e 's/-#[0-9][0-9]*$//'`
	fi

	msg '37;1' READLNK bzImage~
	run -d readlink "$INSTALL_PATH/bzImage~"
	if OOVER="`readlink "$INSTALL_PATH/bzImage"` 2>/dev/null"; then
		OOVER=${OVER#bzImage-}
		OOVER=`printf "%s" "$OOVER" | sed -e 's/-#[0-9][0-9]*$//'`
	fi

	if [ -z "$OVERWRITE_IMAGE" ]; then
		if [ -n "$OOVER" ] && [ "X$OOVER" != "X$VER" ] && \
			[ "X$OOVER" != "X$OVER" ] && [ -d "/lib/modules/$OOVER" ]; then
			msg '37;1' RMDIR "/lib/modules/$OOVER"
			run rm -rf$V -- "/lib/modules/$OOVER"
		fi
	else
		if [ -n "$OVER" ] && [ "X$OVER" != "X$VER" ] && \
			[ "X$OOVER" != "X$OVER" ] && [ -d "/lib/modules/$OVER" ]; then
			msg '37;1' RMDIR "/lib/modules/$OVER"
			run rm -rf$V -- "/lib/modules/$OVER"
		fi
	fi

	run_scripts post-tidy-modules
fi


##
## Copying image
##
if [ -n "$INSTALL_IMAGE" ]; then
	header "Installing kernel image"
	run_scripts pre-install-image

	update_ver
	if [ ! -s .version ]; then BUILD=1; else
		run -ud cat .version
		BUILD=$(printf %d $(run -usf cat .version))
	fi
	msg '37;1' BUILD "$BUILD"
	FVER="$VER-#$BUILD"

	if [ -z "$IMG_PATH" ]; then IMG_PATH="arch/$ARCH/boot/bzImage"; fi
	if [ -z "$MAP_PATH" ]; then MAP_PATH="System.map"; fi

	mkdir -p -m u=rwx,g=rx,o=rx "$INSTALL_PATH"

	set -- "$INSTALL_PATH/bzImage-$FVER" "$INSTALL_PATH/System.map-$FVER" \
		"$INSTALL_PATH/config-$FVER"
	while [ "$1" ]; do
		if [ -f "$1" ]; then
			if [ -f "$1~" ]; then
				set -- "$1~" "$@"
				continue
			fi
			run mv -f$V -- "$1" "$1~"
		fi
		shift
	done
	set --

	msg '37;1' CP bzImage
	run cp $VOPT -- "$IMG_PATH" "$INSTALL_PATH/bzImage-$FVER"

	msg '37;1' CP System.map
	run cp $VOPT -- "$MAP_PATH" "$INSTALL_PATH/System.map-$FVER"

	msg '37;1' CP .config
	run cp $VOPT -- .config "$INSTALL_PATH/config-$FVER"

	for FILE in bzImage System.map config; do
		msg '37;1' READLNK "$FILE"
		run -d readlink "$INSTALL_PATH/$FILE" || true
		LNK=$(readlink "$INSTALL_PATH/$FILE" || true)
		if [ "X$LNK" = "X$FILE-$FVER" ]; then
			msg '37;1' LNK "$FILE~"
			run rm -f$V -- "$INSTALL_PATH/$FILE~"
			run ln -s$V -- "$FILE-$FVER~" "$INSTALL_PATH/$FILE~"
		else
			msg '37;1' LNK "$FILE"
			run mv -f$V -- "$INSTALL_PATH/$FILE" "$INSTALL_PATH/$FILE~" || true
			run ln -fs$V -- "$FILE-$FVER" "$INSTALL_PATH/$FILE"
		fi
	done

	run_scripts post-install-image
fi



##
## Running LILO
##
 r UPDATE_LOADER   'Updating bootloader'           lilo $VOPT



run_scripts post
