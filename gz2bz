#!/bin/sh
##
## gzip to bzip2 converter
## Copyright (c) 2005-2010 by Michal Nazareicz (mina86/AT/mina86.com)
##
## This software is OSI Certified Open Source Software.
## OSI Certified is a certification mark of the Open Source Initiative.
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see <http://www.gnu.org/licenses/>.
##
## This is part of Tiny Applications Collection
##   -> http://tinyapps.sourceforge.net/
##


set -e


##
## Version
##
version () {
	echo 'gz2bz 0.8 (c) 2005-2007 by Michal Nazarewicz (mina86/AT/mina86.com)'
	echo
}


##
## Usage
##
usage () {
	cat <<EOF
usage: <program> <options> [ [--] file ...]
<program> is of the form <from>2<to> where <from> and <to> is one of:
 z or Z                  Meaning compress compression (experimental)
 gz or gzip              Meaning gzip compression
 bz, bz2, bzip or bzip2  Meaning bzip2 compression
 lz or lzma              Meaning lzma compression
 xz                      Meaning xz compression
 <other>                 -C or -D must be specified and it specifies extension
                         of in/out file (experimental, tricky)

<options> are:
 -h --help               Prints this help screen and exits
 -V --verson             Prints version information and exits

 -v --verbose            Becomes more verbose
 -vv                     Becomes even more verbose
 -q --quiet              Supresses all noncritical messages

 -i --interactive        Prompt before overwrite
    --never-overwrite    Never overwrite files

 -1 .. -9                Set compression method
    --fast               Alias of -1
    --best               Alias of -9

 -C --compress=<tool>    Uses <tool> as compression executable
 -c --comp-opts=<opts>   Adds additional arguments to compression tool
 -D --decompress=<tool>  Uses <tool> as decompression executable
 -d --decomp-opts=<opts> Adds additional arguments to decompression tool

 -k --keep               Keeps uncompressed file
 -k --keep=<dir>         Save uncompressed file in <dir>
 -t --tmp                Same as --keep=/tmp
 -K --keep-orig          Keeps original file file
    --keep-both          Alias of --keep --keep-orig

example: gz2bz -9 *.gz
         gz2xz -9 *.gz
         bz2xz -t -9 *.tar.bz2; cd /tmp; cat *.tar | tar x
EOF
}


##
## Prints message if -f given or verbose
##
msg () {
	if [ X"$1" = X-f ]; then
		shift
		echo "${0##*/}: $*" >&2
	elif $VERBOSE; then
		echo "${0##*/}: $*" >&2
	fi
}



##
## Variables
##
false () { return 1; }

COMPRESS=auto
DECOMPRESS=auto
COMPRESS_OPTS=
DECOMPRESS_OPTS=
KEEP_UNCOMPRESSED=false
KEEP_ORIG=false
VERBOSE=false
VERB_OPTS=
OVERWRITE=y
TMP=


##
## Parse args
##
while [ $# -ne 0 ]; do
	case "$1" in
	-h|--help)         usage  ; exit;;
	-V|--version)      version; exit;;

	-v|--verbose)      VERBOSE=:    ; VERB_OPTS=-v ;;
	-vv)               VERBOSE=:    ; VERB_OPTS=-vv;;
	-q|--quiet)        VERBOSE=false; VERB_OPTS=-q ;;

	-i|--interactive)  OVERWRITE=i;;
	--never-overwrite) OVERWRITE=n;;

	-[0-9])            COMPRESS_OPTS="$COMPRESS_OPTS $1";;
	--fast)            COMPRESS_OPTS="$COMPRESS_OPTS -1";;
	--best)            COMPRESS_OPTS="$COMPRESS_OPTS -9";;

	-[GD])             DECOMPRESS="$2"                           ; shift;;
	-[GD]*)            DECOMPRESS="${1#-?}"                             ;;
	--gzip=*|--decompress=*)
	                   DECOMPRESS="${1#*=}"                             ;;
	-[gd])             DECOMPRESS_OPTS="$DECOMPRESS_OPTS $2"     ; shift;;
	-[gd]*)            DECOMPRESS_OPTS="$DECOMPRESS_OPTS ${1#-?}"       ;;
	--gzip-opts=*|--decomp-opts=*)
	                   DECOMPRESS_OPTS="$DECOMPRESS_OPTS ${1#*=}"       ;;
	-[BC])             COMPRESS="$2"                             ; shift;;
	-[BC]*)            COMPRESS="${1#-?}"                               ;;
	--bzip2=*|--compress=*)
	                   COMPRESS="${1#*=}"                               ;;
	-[bc])             COMPRESS_OPTS="$COMPRESS_OPTS $2"         ; shift;;
	-[bc]*)            COMPRESS_OPTS="$COMPRESS_OPTS ${1#-?}"           ;;
	--bzip2-opts=*|--comp-opts=*)
	                   COMPRESS_OPTS="$COMPRESS_OPTS ${1#*=}"           ;;

	-k|--keep)         KEEP_UNCOMPRESSED=:             ;;
	-k*)               KEEP_UNCOMPRESSED=:; TMP=${1#-?};;
	--keep=*)          KEEP_UNCOMPRESSED=:; TMP=${1#*=};;
	-t|--tmp)          KEEP_UNCOMPRESSED=:; TMP=/tmp   ;;
	-K|--keep-gz|--keep-orig)               KEEP_ORIG=:;;
	--keep-both)       KEEP_UNCOMPRESSED=:; KEEP_ORIG=:;;

	--) shift; break;;
	-) break;;
	-*) echo "${0##*/}: Invalid argument: $1" >&2; exit 1;;
	*) break;;
	esac
	shift
done
DECOMPRESS_OPTS="$DECOMPRESS_OPTS $VERB_OPTS"
COMPRESS_OPTS="$COMPRESS_OPTS $VERB_OPTS"
unset VERB_OPTS


##
## Find executables
##
find_exec () {
	__var=$1
	eval __command=\$$__var

	case $__command in auto)
		case $2 in -[CD])
			msg -f "missing $2 option" >&2
			exit 1
		esac
		__command=$2
	esac

	__found=`which "$__command"`
	if [ -z "$__found" ]; then
		msg -f "could not find $__command executable" >&2
		exit 1
	fi

	shift 2
	eval $__var=\"\$__found \$* \$${__var}_OPTS\"
	unset ${__var}_OPTS __var __command __found
}

__prog=${0##*/}
case "$__prog" in
[zZ]2*)                    find_exec DECOMPRESS uncompress; IN_EXT='[Zz]';;
gz2*|gzip2*)               find_exec DECOMPRESS gzip    -d; IN_EXT=gz    ;;
bz2*|bz22*|bzip2*|bzip22*) find_exec DECOMPRESS bzip2   -d; IN_EXT=bz2   ;;
lz2*|lzma2*)               find_exec DECOMPRESS lzma    -d; IN_EXT=lzma  ;;
xz2*)                      find_exec DECOMPRESS xz      -d; IN_EXT=xz    ;;
*)                         find_exec DECOMPRESS -D      -d; IN_EXT=      ;;
esac

case "$__prog" in
*2[zZ])                    find_exec COMPRESS   compress  ; OUT_EXT='[Zz]';;
*2gz|*2gzip)               find_exec COMPRESS   gzip      ; OUT_EXT=gz    ;;
*2bz|*2bz2|*2bzip|*2bzip2) find_exec COMPRESS   bzip2     ; OUT_EXT=bz2   ;;
*2lz|*2lzma)               find_exec COMPRESS   lzma      ; OUT_EXT=lzma  ;;
*2xz)                      find_exec COMPRESS   xz        ; OUT_EXT=xz    ;;
*)                         find_exec COMPRESS   -C        ; OUT_EXT=${0#**2};;
esac
unset __prog


##
## Ask whether to overwrite a file
##
overwrite () {
	[ -e "$1" ] || return 0

	if [ -d "$1" ]; then
		msg -f "$1: is a directory"
		return 1
	fi

	__overwrite=$OVERWRITE
	while :; do
		case "$__overwrite" in
		[yY]|[yY][eE][sS]|'')
			unset __overwrite
			return 0
			;;
		[nN]|[nN][oO])
			msg -f "$1: exists; not overwriting"
			unset __overwrite
			return 1
			;;
		*)
			printf '%s: %s: exists; overwrite? [Y/n]: ' "${0##*/}" "$1"
			read __overwrite || __overwrite=n
		esac
	done
}



##
## Do the job
##
[ $# -ne 0 ] || set -- -
for FILE; do
	## standard input -> standard output
	if [ X"$FILE" = X- ]; then
		msg Converting stdin to stdout
		$DECOMPRESS | $COMPRESS || msg -f "$FILE: failed"
		continue
	fi

	## Get output file name
	case "$FILE" in
	*.tgz) OUTPUT=${FILE%.tgz}.tar.gz  ;;
	*.tbz) OUTPUT=${FILE%.tbz}.tar.bz2 ;;
	*.txz) OUTPUT=${FILE%.txz}.tar.xz  ;;
	*.tlz) OUTPUT=${FILE%.tlz}.tar.lzma;;
	*)     OUTPUT=$FILE
	esac

	case "$OUTPUT" in
	*.$IN_EXT)  OUTPUT="${OUTPUT%.$IN_EXT}" ;;
	*)          msg -f "$FILE: invalid extension, skipping"; continue
	esac

	OUTPUT_COMPRESSED=$OUTPUT.$OUT_EXT
	if [ -n "$TMP" ]; then
		OUTPUT=$TMP/${OUTPUT##*/}
	fi

	## Convert
	OK=false
	overwrite "$OUTPUT_COMPRESSED" || continue
	if $KEEP_UNCOMPRESSED; then
		overwrite "$OUTPUT" || continue
		msg decompressing "$FILE" to "$OUTPUT"
		if $DECOMPRESS <"$FILE" >"$OUTPUT"; then
			msg compressing "$OUTPUT" to "$OUTPUT_COMPRESSED"
			if ! $COMPRESS <"$OUTPUT" >"$OUTPUT_COMPRESSED"; then
				rm -f -- "$OUTPUT_COMPRESSED"
			else
				OK=:
			fi
		else
			rm -f -- "$OUTPUT"
		fi
	else
		msg converting "$FILE" to "$OUTPUT_COMPRESSED"
		if $DECOMPRESS <"$FILE" | $COMPRESS >"$OUTPUT_COMPRESSED"; then
			OK=:
		else
			rm -f -- "$OUTPUT_COMPRESSED"
		fi
	fi

	## Finish
	if ! $OK; then
		msg -f "$FILE: failed"
	elif ! $KEEP_ORIG; then
		msg removing "$FILE"
		rm -f -- "$FILE"
	fi
done
